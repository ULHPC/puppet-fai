#! /bin/bash
################################################################################
# /root/bin/faiplay
# Wrapper/helper to pilot FAI (Fully Automatic Installation) operations
#                         __       _       _
#                        / _| __ _(_)_ __ | | __ _ _   _
#                       | |_ / _` | | '_ \| |/ _` | | | |
#                       |  _| (_| | | |_) | | (_| | |_| |
#                       |_|  \__,_|_| .__/|_|\__,_|\__, |
#                                   |_|            |___/
################################################################################
#" /!\ DO NOT EDIT THIS FILE: it has been automatically generated by Puppet.
#      In particular, any further changes will be overwritten at the next
#      puppet invocation
################################################################################
# Author : Sebastien Varrette <Sebastien.Varrette@uni.lu>
#          (Web page : http://varrette.gforge.uni.lu)
#
# Description : see the print_help function or launch 'faiplay --help'
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
################################################################################

### Global variables
VERSION=0.4
COMMAND=`basename $0`
VERBOSE=""
DEBUG=""
QUIET=""
FORCE_MODE=""

### displayed colors
COLOR_GREEN="\033[0;32m"
COLOR_RED="\033[0;31m"
COLOR_YELLOW="\033[0;33m"
COLOR_VIOLET="\033[0;35m"
COLOR_CYAN="\033[0;36m"
COLOR_BOLD="\033[1m"
COLOR_BACK="\033[0m"

PRINT_WIDTH=80     # minimal width for all prints with a status information on the right


### Specific variables
FAI_CONFIG_DIR="<%= scope.lookupvar('fai::configspacedir') %>"   # directory containing the FAI configuration
<% if @lsbdistcodename == 'wheezy' -%>
# Set FAI_CONFIG_SRC to URL. Setting this variable is mandatory for operation of FAI.
FAI_CONFIG_SRC=nfs://<%= @fqdn %>/<%= scope.lookupvar('fai::configspacedir') %>
<% end -%>
FAI_TFTP_DIR="<%= scope.lookupvar('fai::tftpdir') %>"       # directory containing the FAI tftp configuration
FAI_LOGDIR="/tmp/fai"              # base directory for the FAI logs on the nodes during installation
FAICHBOOT="/usr/sbin/fai-chboot"   # hard path (without which) as I want to use it without root access

DHCPD_LOG="/var/log/dhcpd.log"     # local log file for DHCPD to detect dhcpd offer to cluster nodes

SSH_AUTHORIZED_USER="root"                # user recognized for SSH public key authentication on the installed nodes
NODES=""                           # the nodes to consider for operation     - DO NOT MODIFY
NODES_UNREACHABLE=""               # the nodes that can't be accessed by SSH - DO NOT MODIFY
FIRST_NODE=""                      # the first node of ${NODES}              - DO NOT MODIFY
TAIL_NODES=""                      # the rest of the nodes in ${NODES}       - DO NOT MODIFY
LIVE_NETDEV=""                     # Don't set the net dev interface

# Operation modes
MODE_REBOOT=""                     # reboot the nodes listed in ${NODES}
MODE_SOFTREBOOT=""                 # reboot in softmod (use IPMI by default)
MODE_CHECKSSH=""                   # only check reachability of ${NODES} by SSH for the user ${SSH_AUTHORIZED_USER}
MODE_INSTALL=""                    # install the nodes listed by ${NODES} using FAI
MODE_STATUS=""                     # get state info on the nodes

FORCE=""

### various info on cluster nodes ###
CLUSTERNODES_BASEHOSTNAME="<%= scope.lookupvar('fai::deploynode_basename') %>"  # common prefix for the hostname of all nodes in the cluster
ALL_CLUSTER_NODES=`seq -s " " -f "${CLUSTERNODES_BASEHOSTNAME}%g" <%= scope.lookupvar('fai::deploynode_minindex') %> <%= scope.lookupvar('fai::deploynode_maxindex') %>`

### IPMI elements
IPMI_USER="<%= scope.lookupvar('fai::ipmiuser') %>"

### Kernel parameters
echo $HOSTNAME | grep nyx-cluster && APPEND_KERNEL_PARAM="console=tty0 console=ttyS0,115200n8"

#######################
### print functions ###
#######################

####
# print version of this program
##
print_version() {
    cat <<EOF
This is $COMMAND version "$VERSION".
Copyright (c) 2007 Sebastien Varrette  (http://www-id.imag.fr/~svarrett/)
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
EOF
}

####
# print help
##
print_help() {
    cat <<EOF
NAME
    $COMMAND -- pilot various operation for the Fully Automatic Installation of the Chaos.lu cluster.

SYNOPSIS
    $COMMAND [-h|-V]
    $COMMAND [-v] [--debug] get       { [-p] | [-b node1 node2...] }
    $COMMAND [-v] [--debug] set       { [-p total|partial] | [-i|-l node1 node2...] }

DESCRIPTION
    $COMMAND handle various task on this FAI server. More precisely, this script covers the following operations:
    - initializing the FAI configuration using fai-setup
    - setting various configurations, including localdisk or pxe boot for installation
    - getting various configuration informations
    - launching the FAI installation of specified nodes
    - monitoring the installation process
    - check SSH access
    - force remote reboot of specified nodes
    - remote access by SSH on specific nodes
    - etc.
    Some commands required the hostname of the client nodes affected by the operation. This can be done either by listing all the
    hostnames (which can quickly be boring), or by integers corresponding to the node number. For instance, '2' will be expanded
    to '${CLUSTERNODES_BASEHOSTNAME}2' and '2-4' to '${CLUSTERNODES_BASEHOSTNAME}2 ${CLUSTERNODES_BASEHOSTNAME}3 ${CLUSTERNODES_BASEHOSTNAME}4' (see the CLUSTERNODES_BASEHOSTNAME variable).
    You can also use the --all option to apply the selected operation on all nodes of the cluster (see the ALL_CLUSTER_NODES variable)

OPTIONS
    -h --help
        Display a help screen and quit.

    --debug
        Display debugging messages.

    -v --verbose
        Verbose mode.

    -V --version
        Display the version number then quit.

    cleanssh
        empty \$HOME/.ssh/known_hosts and ~oar/.ssh/known_hosts to avoir warning messages durinng SSH connection after reinstallation (which create a set of new SSH keys)

    get -p
    get -b node1 node2...
            Get various configuration infos. The nodes to look for can be specified using integer shortcuts (see above).
        Available options includes:

        -b | --boot-mode | boot-mode
               Get PXE boot configuration for the specified nodes. Use --all in place of node enumeration to select all the cluster nodes

    monitor -d
    monitor -i    node1 node2...
    monitor -e    node1 node2...
    monitor --fai node1 node2...
        Monitor through log view various aspect of the FAI installation. Use -m as a shortcut for this command.
        Available options includes:

            -d | --dhcpd   | dhcpd
               Monitor DHCPD logs on this server to find traces of DHCPOFFERS

        --fai
               Monitor successively the logs of the installation process

        -i | --install | install
               Monitor remote FAI log file to follow the installation process

            -e | --errors  | errors
               Monitor remote FAI installation error.

    reboot [-s] node1 node2...
            Force the reboot (in softmod with -s) of the selected nodes. Use -r as a shortcut for this command.

    set [-r] [-s] -i node1 node2...
    set [-r] [-s] -l node1 node2...
            Set various configurations. The nodes affected by the configuration can be specified using integer shortcuts (see above).
        Use --all in place of node enumeration to select all the cluster nodes
        Available options are the following:

        -i | --install | install
               Configure PXE boot for FAI installation on future reboot of the specified nodes
               Combining with the -r option leads to rebooting the specified nodes

        -l | --localboot | localboot
               Configure localdisk boot for the future reboot of the specified nodes
               Combining with the -r option leads to rebooting the specified nodes

        -r | --reboot  | reboot
               Also reboot the nodes successfully configured
               COmbined with -s to have a softmod reboot rather than the default ipmi reboot

    setup
        Lauch the fai-setup process to setup FAI according to the configuration files located in /etc/fai/
        see fai-setup(1) for more information

    ssh node1 node2...
        Successively connect through SSH as root on specified nodes using public key authentication only. The nodes to connect can be specified
        using integer shortcuts (see above).

AUTHOR
    Sebastien Varrette <Sebastien.Varrette@imag.fr>
    Web page: http://www-id.imag.fr/~svarrett/

REPORTING BUGS
    Please report bugs to <Sebastien.Varrette@imag.fr>

COPYRIGHT
    This is free software; see the source for copying conditions.  There is NO
    warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

SEE ALSO
    FAI - Fully Automatic Installation - http://www.informatik.uni-koeln.de/fai/
    Other scripts are available on my web site http://www-id.imag.fr/~svarrett/
EOF
}

######
# Print information in the following form: '[$2] $1' ($2=INFO if not submitted)
# usage: info text [title]
##
info() {
    [ -z "$1" ] && print_error_and_exit "[$FUNCNAME] missing text argument"
    local text=$1
    local title=$2
    # add default title if not submitted but don't print anything
    [ -n "$text" ] && text="${title:==>} $text"
    #echo -en $text
    echo -e $text
    # echo -en \\033[${PRINT_WIDTH}G
}

#####
# print the strings [ OK ] or [ FAILED ] or [ FAILED ]\n$1
##
print_ok()     { echo -e "[   ${COLOR_GREEN}OK${COLOR_BACK}   ]"; }
print_failed() { echo -e "[ ${COLOR_RED}FAILED${COLOR_BACK} ]"; }
print_failed_and_exit() {
    print_failed
    [ ! -z "$1" ] && echo "$1"
    exit 1
}

#####
# Print debug information if verbose mode enabled
# usage: debug text
##
debug()    {     [ -n "$DEBUG" ] && info "$1" "[${COLOR_YELLOW}DEBUG${COLOR_BACK}]"; }
warning()  {  info "$*" "[${COLOR_CYAN}WARNING${COLOR_BACK}]"; }
title()    {  info " ${COLOR_BOLD}$1${COLOR_BACK} ===" "==="; }

#####
# Print error message
# usage: error text
##
error() {     info "$1" "[${COLOR_RED}ERROR${COLOR_BACK}]"; }
print_error_and_exit() {
    local text=$1
    [ -z "$1" ] && text=" Bad format"
    error  "$text. '$COMMAND -h' for help."
    exit 1
}

#########################
### toolbox functions ###
#########################

####
# ask to continue. exit 1 if the answer is no
# usage: really_continue text
##
really_continue() {
    echo -e -n "$1 Are you sure you want to continue? [Y|n] "
    read ans
    case $ans in
        n*|N*) exit 1;;
    esac
}

#####
# Check availability of binaries passed as arguments on the current system
# usage: check_bin prog1 prog2 ...
##
check_bin() {
    [ $# -eq 0 ] && print_error_and_exit "[$FUNCNAME] missing argument"
    debug "[$FUNCNAME] programs to check: $*"
    for appl in $*; do
        [ -z "$QUIET" ] && echo -n -e "=> checking availability of the command '$appl' on your system \t"
        local tmp=`which $appl`
        if [ -z "$tmp" ]; then
            print_failed_and_exit "Please install $appl or check \$PATH."
        else
            [ -z "$QUIET" ] && print_ok
        fi
    done
}

####
# get the IP adress associated with a node using a DNS request, eventually in hexadecimal format
# usage: get_IP_from [--hex] host
###
get_IP_from() {
    [ $# -eq 0 ] && print_error_and_exit "[$FUNCNAME] usage: $FUNCNAME [--hex] host "
    local hex_display=""
    local host=$1
    if [ "$1" == "--hex" ]; then
        hex_display="--hex"
        [ -z "$2" ] && print_error_and_exit "[$FUNCNAME] missing host "
        host=$2
    fi
    local ip=`host $host | grep address |  sed -e 's/.*address[ ]*//'`
    if [ -n "$hex_display" ]; then
        printf '%02X' ${ip//./ }; echo
    else
        echo "$ip"
    fi
}

###################################################
### Command executions - either local or remote ###
###################################################

#####
# execute a local command
# usage: execute command
###
execute() {
    [ $# -eq 0 ] && print_error_and_exit "[$FUNCNAME] missing command argument"
    debug "[$FUNCNAME] $*"
    eval $*
    local exit_status=$?
    debug "[$FUNCNAME] exit status: $exit_status"
    return $exit_status
}

#####
# execute a remote command with root permission throught ${SSH_AUTHORIZED_USER}
# usage: remote_execute host command
###
remote_execute() {
    [ $# -le "1" ] && print_error_and_exit "[$FUNCNAME] missing host and/or command argument"
    local host=$1
    shift
    local cmd="";
    if [ -n "${SSH_AUTHORIZED_USER}" ]; then
        cmd="sudo -u ${SSH_AUTHORIZED_USER}"
    fi
    cmd="$cmd ssh -o 'PasswordAuthentication=no' -o 'StrictHostKeyChecking=no' root@${host} $*"
    debug "[$FUNCNAME] $cmd"
    eval $cmd
    local exit_status=$?
    debug "[$FUNCNAME] exit status: $exit_status"
    return $exit_status
}

####
# reboot a node by IPMI (assumes ipmitool is installed and IPMI_PASSWORD is set)
##
ipmi_reboot(){
    [ $# -ne "1" ] && print_error_and_exit "[$FUNCNAME] missing host argument"
    local host=$1
    execute "ipmitool -U ${IPMI_USER} -E -H ${host}-bmc chassis power reset"
    return $?
}


#####
# tail remote file.
# usage: tail_remote_log host filename [any tail option -- see tail(1)]
###
tail_remote_file() {
    [ $# -le "1" ] && print_error_and_exit "[$FUNCNAME] missing host and/or file argument"
    local host=$1; shift
    local file=$1; shift
    debug "[$FUNCNAME] host: $host"
    debug "[$FUNCNAME] file: $file"
    debug "[$FUNCNAME] remaining arguments: $*"
    remote_execute $host "tail $* $file 2>/dev/null"
    #remote_execute $host "cat $file 2>/dev/null"
    return $?
}

#####
# cat remote file.
# usage: cat_remote_log host filename
###
cat_remote_file() {
    [ $# -le "1" ] && print_error_and_exit "[$FUNCNAME] missing host and/or file argument"
    local host=$1; shift
    local file=$1; shift
    debug "[$FUNCNAME] host: $host"
    debug "[$FUNCNAME] file: $file"
    debug "[$FUNCNAME] remaining arguments: $*"
    remote_execute $host "cat $file 2>/dev/null"
    return $?
}

##########################
### Variables settings ###
##########################

####
# echo the head element and the tail of a white spaced list
##
get_head_element_from() { echo $* | cut -d " " -f 1; }
get_tail_element_from() { echo $* | sed -e 's/^[[:alnum:]_-]*[ ]*//'; }

####
# update ${NODES} and associated variables
###
set_head_node()    { FIRST_NODE=`get_head_element_from ${NODES}`; }
set_tail_nodes()   { TAIL_NODES=`get_tail_element_from ${NODES}`; }
update_node_list() {
    NODES="$*"
    set_head_node
    set_tail_nodes
}
####
# remove the leading node of ${NODES} and update the associated variables
###
remove_head_node() { update_node_list ${TAIL_NODES}; }

######
# initialize the NODES variable according to the command line
# usage: configure_nodes_variable
#        configure_nodes_variable host1 host2 ....
#        configure_nodes_variable a-b     # a and b are integers
#        configure_nodes_variable a       # a is an integer
####
configure_nodes_variable() {
    [ -n "${NODES}" ] && return
    [ $# -eq 0 ] && print_error_and_exit "Please precise the nodes on which I could operate"
    # check if the argument has the form a-b where a and b are numbers
    local tmp=`echo $* | grep -e "^[[:digit:]]*-[[:digit:]]*"`
    if [ -n "$tmp" ]; then
        local start=`echo $tmp | cut -d - -f 1`
        local end=`echo $tmp | cut -d - -f 2`
        #NODES=`seq -s " " -f "${CLUSTERNODES_BASEHOSTNAME}%02g" $start $end`
        NODES=`seq -s " " -f "${CLUSTERNODES_BASEHOSTNAME}%g" $start $end`
    else
        tmp=`echo $* | grep -e "^[[:digit:]]"`
        [ -n "$tmp" ] && NODES=`printf "${CLUSTERNODES_BASEHOSTNAME}%g " $tmp` || NODES="$*"
    fi
    # for the moment, extract node-01
    #NODES=`echo ${NODES} | sed -e "s/node-01//"`
    set_head_node
    set_tail_nodes
    debug "[$FUNCNAME] NODES: ${NODES}"
    debug "[$FUNCNAME] FIRST_NODE: ${FIRST_NODE}"
    debug "[$FUNCNAME] TAIL_NODES: ${TAIL_NODES}"
}

####
# check the validity of ${FAI_CONFIG_DIR}
##
check_faiconfig_dir() {
    [ -d "${FAI_CONFIG_DIR}" ] || print_error_and_exit "${FAI_CONFIG_DIR} not present on this system"
}

#############################################################################
### Actions to performs on nodes listed in ${NODES} or on a specific node ###
#############################################################################

####
# check state of the FAI process
# usage:  check_FAI_process      -> check on all node listed in ${NODES}
#         check_FAI_process node -> check only on node
##
check_FAI_process() {
    local node_to_check=${NODES}
    [ -n "$1" ] && node_to_check="$1"
    for node in $node_to_check; do
        local node_state="UNKNOWN"
        remote_execute $node "ls ${FAI_LOGDIR}/fai.log" &>/dev/null
        if [ "$?" -ne "0" ]; then
            node_state="installed and rebooted on the new system"
            # go deeper into the analysis of this issue:
            # if the node belongs to ${NODES_UNREACHABLE}, then it is unreacheable
            [ -n "`echo ${NODES_UNREACHABLE} | grep $node`" ] && node_state="${COLOR_RED}UNREACHABLE${COLOR_BACK}"
        else node_state="FAI processing"
        fi
        info "current state of $node : \t $node_state"
    done
}

######
# check the accessibility of nodes listed in ${NODES} through ssh using ${SSH_AUTHORIZED_USER}
# usage: check_nodes_availability       -> check all nodes listed in ${NODES}
#        check_nodes_availability node  -> check only node
###
check_nodes_availability() {
    local node_to_check=${NODES}
    [ -n "$1" ] && node_to_check="$1"
    for node in $node_to_check; do
        echo -n -e "=> check SSH access to $node \t"
        #remote_execute $node ls -l $HOME &>/dev/null
        remote_execute $node hostname &>/dev/null
        if [ "$?" -ne "0" ]; then
            # can't access to the node by SSH: remove this node from ${NODES} and add it to ${NODES_UNREACHABLE}
            NODES_UNREACHABLE="${NODES_UNREACHABLE} $node"
            NODES=`echo ${NODES} | sed -e "s/$node//"`
            set_head_node
            set_tail_nodes
            print_failed
        else print_ok
        fi
    done
    debug "[$FUNCNAME] NODES: ${NODES}"
    debug "[$FUNCNAME] FIRST_NODE: ${FIRST_NODE}"
    debug "[$FUNCNAME] TAIL_NODES: ${TAIL_NODES}"
    [ -z "$1" ] && [ -n "${NODES_UNREACHABLE}" ] && warning "The following nodes have been ${COLOR_BOLD}removed${COLOR_BACK} from the list of available nodes: ${NODES_UNREACHABLE}"
    [ -z "$1" ] && [ -z "${NODES}" ] && print_error_and_exit "No node can be reached by SSH => exiting"
}

#####
# configure the nodes listed in ${NODES} for booting on the local disk (even if the BIOS is configured with
# a first PXE boot
# usage:   configure_localdisk_boot       -> perfom action on all nodes listed in ${NODES}
#          configure_localdisk_boot  node -> perform action only on node
###
configure_localdisk_boot() {
    MODE_SOFTREBOOT="yes"    # Force (eventually) soft reboot even if not precised by command line
    local node_to_configure=${NODES}
    [ -n "$1" ] && node_to_configure="$1"
    for node in $node_to_configure; do
        echo -n -e "=> configuring boot on local disk for ${COLOR_BOLD}$node${COLOR_BACK} \t"
        [ -n "${VERBOSE}" ] && echo
        ${FAICHBOOT} -o ${VERBOSE} $node
        local exit_status=$?
        if [ -z "${VERBOSE}" ]; then
            [ "$exit_status" -ne "0" ] && print_failed || print_ok
        else echo
        fi
        [ -n "${MODE_REBOOT}" ] && reboot $node
    done
}

#####
# configure the nodes listed in ${NODES} for booting on PXE for reinstall
# usage:   configure_PXE_boot       -> perfom action on all nodes listed in ${NODES}
#          configure_PXE_boot  node -> perform action only on node
###
configure_PXE_boot() { # TODO factorize code with the previous function
    local node_to_configure=${NODES}
    local verbose=""

    [ -n "$1" ] && node_to_configure="$1"
    for node in $node_to_configure; do
        echo -n -e "=> configuring PXE boot for ${COLOR_BOLD}$node${COLOR_BACK} \t"
        [ -n "${VERBOSE}" ] && echo
        [ -n "${LIVE_NETDEV}" ] && APPEND_KERNEL_PARAM="${APPEND_KERNEL_PARAM} live-netdev=${LIVE_NETDEV}"
        ${FAICHBOOT} -P -IF ${VERBOSE} ${APPEND_KERNEL_PARAM:+-k "$APPEND_KERNEL_PARAM"} ${FAI_CONFIG_SRC+-u "$FAI_CONFIG_SRC"} $node
        local exit_status=$?
        if [ -z "${VERBOSE}" ]; then
            [ "$exit_status" -ne "0" ] && print_failed || print_ok
        else echo
        fi
        [ -n "${MODE_REBOOT}" ] && reboot $node
    done
}

#####
# launch  the install of all the nodes listed in ${NODES}
###
install() {
    local saved_nodes="${NODES}"  # backup nodes list
    configure_PXE_boot
    cleanssh
    reboot
    monitor_dhcpd
    trap "echo -n ''" SIGINT     # trap ssh exit
    monitor_FAI_install
    update_node_list $saved_nodes     # restore NODES variable as the previous function altered it
    title "[FAI] Monitor FAI errors"
    monitor_FAI_errors
    update_node_list $saved_nodes     # restore NODES variable as the previous function altered it
    title "[FAI] Configuring PXE for local boot"
    configure_localdisk_boot
    reboot
    trap - SIGINT
    title "END INSTALLATION PROCESS" && echo
}

#####
# reboot the nodes listed in ${NODE} or in argument
# usage:  reboot         -> reboot all nodes listed in ${NODES}
#         reboot node    -> reboot only node
###
reboot() {
    local node_to_reboot=${NODES}
    while [ $# -ge 1 ]; do
        case $1 in
            -h | --help)    print_help;        exit 0;;
            -V | --version) print_version;     exit 0;;
            -s | --softmod) MODE_SOFTREBOOT="--soft";;
            -f | --force)   FORCE="--force";;
            --debug)        DEBUG="--debug";;
            *) node_to_reboot="$1"
        esac
        shift
    done
    go_for_ipmi=""
    if [ -z "${MODE_SOFTREBOOT}" ]; then
        really_continue "IPMI will be used to reboot the selected nodes"
        go_for_ipmi="yes"
    fi
    # debug "force mode = ${FORCE}"
    # debug "go_for_ipmi = ${go_for_ipmi}"
    for node in $node_to_reboot; do
        [ -z "${FORCE}" ] && really_continue "You are about to ${COLOR_BOLD}force reboot${COLOR_BACK} on $node"
        if [ -n "${MODE_SOFTREBOOT}" ]; then
            echo -n -e "=> rebooting ${COLOR_BOLD}$node${COLOR_BACK} \t"
            remote_execute $node shutdown -r now
            status=$?
            [ "$status" -ne "0" ] && print_failed || print_ok
            if [ "$status" -ne "0" ]; then
                really_continue "Do you want to use IPMI to ${COLOR_BOLD}force the reboot${COLOR_BACK} of the node $node"
                go_for_ipmi="yes"
            fi
        fi
        [ -n "${go_for_ipmi}" ] && ipmi_reboot $node || echo "not rebooting by IPMI"
    done
}

#####
# start an SSH connection to the first node listed in ${NODES}
# usage: sshconnect_to      -> connect successively to all nodes listed in ${NODES}
#        sshconnect_to node -> connect to node
##
sshconnect_to() {
    local node_to_connect=${NODES}
    [ -n "$1" ] && node_to_connect="$1"
    for node in $node_to_connect; do
        [ -n "${VERBOSE}" ] && really_continue "[${COLOR_CYAN}WARNING${COLOR_BACK}] You are about to connect as ${COLOR_BOLD}root@${FIRST_NODE}${COLOR_BACK}."
        echo && title "SSH connection to root@$node"
        local cmd="";
        if [ -n "${SSH_AUTHORIZED_USER}" ]; then
            cmd="sudo -u ${SSH_AUTHORIZED_USER}"
        fi
        cmd="$cmd ssh -o 'PasswordAuthentication=no' -o 'StrictHostKeyChecking=no' root@${node}"
        #   local cmd="sudo -u ${SSH_AUTHORIZED_USER} ssh -o 'PasswordAuthentication=no' root@$node"
        debug "[$FUNCNAME] $cmd"
        trap "echo -n ''" SIGINT     # trap ssh exit
        eval $cmd
        debug "[$FUNCNAME] exit status: $?"
        trap - SIGINT                # restore default handler for the SIGINT signal
        title "End SSH connection to $node" && echo
    done
}


#####
# start an SSH connection to the first node listed in ${NODES}
# WARNING: recursive function to avoid the trap but which alter the NODES variable!!!
##
#sshconnect_to() {
#    [ -z "${NODES}" ] && exit 0
#    really_continue "You are about to connect as ${COLOR_BOLD}root@${FIRST_NODE}${COLOR_BACK}."
#    [ -n "${FIRST_NODE}" ]  && connect_to ${FIRST_NODE}
#    remove_head_node
#    sshconnect_to  # recursive call
#}

#####
# connect by SSH on node
# usage: connect_to node
###
#connect_to() {
#    [ $# -eq "0" ] && print_error_and_exit "[$FUNCNAME] missing node name to connect to"
#    local node=$1
#    echo && title "SSH connection to root@$node"
#    local cmd="sudo -u ${SSH_AUTHORIZED_USER} ssh -o 'PasswordAuthentication=no' root@$node"
#    debug "[$FUNCNAME] $cmd"
#    eval $cmd
#    debug "[$FUNCNAME] exit status: $?"
#    title "End SSH connection to $node" && echo
#}

####
# retrieve the boot configuration for the nodes listed in ${NODES}
# usage: get_boot_mode      -> get config from all nodes listed in ${NODES}
#        get_boot_mode node -> get config only
###
get_boot_mode() {
    local node_to_check=${NODES}
    [ -n "$1" ] && node_to_check="$1"
    for node in $node_to_check; do
        local node_ip=`get_IP_from $node`
        [ -z "$node_ip" ] && error "cannot retrieve the IP adress for $node -> stop analysis of $node" && continue
        local node_ip_hex=`get_IP_from --hex $node`
        local pxe_configfile="${FAI_TFTP_DIR}/pxelinux.cfg/$node_ip_hex"
        debug "@ IP for $node: $node_ip (in hexa: $node_ip_hex) - PXE config file: $pxe_configfile"
        local state="${COLOR_RED}UNKNOWN${COLOR_BACK}"
        # first check if a configuration file exists
        [ ! -f "$pxe_configfile" ] && state="${COLOR_RED}NO CONFIG FOUND${COLOR_BACK}"
        # then check for localboot
        local check_localboot=`grep localboot $pxe_configfile 2>/dev/null`
        [ -n "$check_localboot" ]  && state="${COLOR_GREEN}$check_localboot${COLOR_BACK}"
        # finally check for install
        local kernel=`grep kernel $pxe_configfile 2>/dev/null | cut -d ' ' -f 2`
        local fai_action=`grep FAI_ACTION $pxe_configfile 2>/dev/null`
        [ -n "$kernel" -a -n "$fai_action" ] && state="${COLOR_CYAN}install $kernel${COLOR_BACK}"
        info "PXE configuration for ${COLOR_BOLD}$node${COLOR_BACK} : $state"
        [ -n "${VERBOSE}" -a  -f "$pxe_configfile" ] && cat $pxe_configfile
    done
}


####
# launch fai-setup
###
fai_setup() {
    check_bin fai-setup
    local fai_setup_log="/tmp/fai-setup.$$.log"

    echo && title "Setup FAI"
    #fai-setup $verbose 2>&1 | tee $fai_setup_log
<% if @lsbdistcodename == 'squeeze' -%>
    fai-setup ${VERBOSE}
<% else -%>
    fai-setup -f ${VERBOSE}
<% end -%>
    title "End setup FAI" && echo
}

#################
### Log views ###
#################

#####
# monitor remote log file; title is used to
# WARNING: this function is made recusive to avoid exiting on CTRL-C. Consequently, the NODES variable is altered!
# usage: monitor_remote_log title logfile      -> monitor logfile successively all nodes listed in ${NODES}
#        monitor_remote_log title logfile node -> monitor only on node
###
monitor_remote_log() {
    [ -z "${NODES}" ] && exit 0
    [ $# -le "1" ] && print_error_and_exit "[$FUNCNAME] missing title and/or logfile argument"
    local title=$1
    local log_file=$2
    local node_to_monitor=${FIRST_NODE}
    [ -n "$3" ] && node_to_monitor="$3"

    really_continue "You are about to $title on ${COLOR_BOLD}$node_to_monitor${COLOR_BACK}."
    echo && title "$title on $node_to_monitor"
    tail_remote_file $node_to_monitor $log_file -f
    local exit_status=$?
    # exit status 130 for exiting the tail -f with CTRL-C
    [ "$exit_status" -ne "0" ] && [ "$exit_status" -ne "130" ] && error "Unable to access to $log_file on ${FIRST_NODE}. This can mean that ${FIRST_NODE} is not currently in the FAI process."
    title "End $title on $node_to_monitor" && echo

    if [ -z "$3" ]; then
        remove_head_node   # Note that this alter ${NODES}!
        monitor_remote_log  "$title" "$log_file" # recursive call to check all nodes
    fi
    return $exit_status
}

monitor_remote_log_nonrec() {
    [ -z "${NODES}" ] && exit 0
    [ $# -le "1" ] && print_error_and_exit "[$FUNCNAME] missing title and/or logfile argument"
    local title=$1
    local log_file=$2
    local node_to_monitor=${FIRST_NODE}
    [ -n "$3" ] && node_to_monitor="$3"

    really_continue "You are about to $title on ${COLOR_BOLD}$node_to_monitor${COLOR_BACK}."
    echo && title "$title on $node_to_monitor"
    tail_remote_file $node_to_monitor $log_file -f
    local exit_status=$?
    # exit status 130 for exiting the tail -f with CTRL-C
    [ "$exit_status" -ne "0" ] && [ "$exit_status" -ne "130" ] && error "Unable to access to $log_file on ${FIRST_NODE}. This can mean that ${FIRST_NODE} is not currently in the FAI process."
    title "End $title on $node_to_monitor" && echo

    if [ -z "$3" ]; then
        remove_head_node   # Note that this alter ${NODES}!
        monitor_remote_log  "$title" "$log_file" # recursive call to check all nodes
    fi
    return $exit_status
}

#####
# monitor the remote FAI installation on the nodes listed in ${NODES} or in the argument
# usage: monitor_FAI_install       -> monitor successively all nodes listed in ${NODES}
#        monitor_FAI_install node  -> monitor only on node
###
monitor_FAI_install() {
    local log_file="${FAI_LOGDIR}/fai.log"
    monitor_remote_log "monitor FAI install process" $log_file $1
}

#####
# show FAI install errors
# usage:  monitor_FAI_errors      -> monitor on all nodes listed in ${NODES}
#         monitor_FAI_errors node -> monitor only on node
###
monitor_FAI_errors() {
    local log_file="${FAI_LOGDIR}/error.log"
    monitor_remote_log "monitor FAI error process" $log_file $1
}

####
# check for DHCPOFFER entries in ${DHCPD_LOG}
# TODO: check IP if host argument
##
monitor_dhcpd() {
    if [ -f "${DHCPD_LOG}" ]; then
        echo && title "Monitor DHCPD logs for DHCPOFFER"
        debug "looking in ${DHCPD_LOG} for DHCPOFFER"
        trap "echo -n ''" SIGINT
        tail -n 100 -f ${DHCPD_LOG}  | grep DHCPOFFER
        trap - SIGINT     # restore default handler for the SIGINT signal
        title "End monitor DHCPD logs for DHCPOFFER" && echo
    else
        error "${DHCPD_LOG} can't be found"
    fi
}

####
# monitor all the FAI process
##
monitor_FAI() {
    local saved_nodes="${NODES}"  # backup nodes list
    title "[FAI] Monitor DHCPD"
    monitor_dhcpd
    title "[FAI] Monitor FAI installation"
    monitor_FAI_install
    update_node_list $saved_nodes     # restore NODES variable as the previous function altered it
    title "[FAI] Monitor FAI errors"
    monitor_FAI_errors
    update_node_list $saved_nodes     # restore NODES variable as the previous function altered it
}

########################
### Command handlers ###
########################

#####
# clean ssh known_host file
###
cleanssh() {
    echo -n -e  "=> cleaning $HOME/.ssh/known_hosts \t"
    echo "" > $HOME/.ssh/known_hosts
    [ "$?" -ne "0" ] && print_failed || print_ok
    #echo -n -e  "=> cleaning ~oar/.ssh/known_hosts \t"
    #echo "" > ~oar/.ssh/known_hosts
    #[ "$?" -ne "0" ] && print_failed || print_ok
}

#####
# handle the status command which gives state informations on the specified nodes
# usage: status      -> show state info on all nodes listed in ${NODES}
#        status node -> show only infos relative to node
###
status() {
    local node_list=${NODES}
    [ -n "$1" ] && node_list="$1"
    for node in $node_list; do
        echo && title "state information on $node"
        get_boot_mode            $node
        check_nodes_availability $node
        check_FAI_process        $node
    done
}

#####
# handle the monitor command
###
monitor() {
    [ $# -eq 0 ] && print_error_and_exit "[$FUNCNAME] please precise what you want to monitor"
    local function=""
    while [ $# -ge 1 ]; do
        case $1 in
            -h | --help)    print_help;        exit 0;;
            -V | --version) print_version;     exit 0;;
            --debug)        DEBUG="--debug";;
            --all)          NODES="${ALL_CLUSTER_NODES}";;
            -v | --verbose) VERBOSE="-v";;
            -d | --dhcpd   | dhcpd)    function="monitor_dhcpd";;
            --fai | fai)               function="monitor_FAI";;
            -i | --install | install)  function="monitor_FAI_install";;
            -e | --errors  | errors)   function="monitor_FAI_errors";;
            *)  [ -z "$function" ] && print_error_and_exit "[$FUNCNAME] unknown get option";
                configure_nodes_variable $@
        esac
        shift
    done
    [ "$function" !=  "monitor_dhcpd" ] && check_nodes_availability  # ensure all the nodes are accessible
    eval $function
}

#####
# Set various configuration
###
set_config() {
    [ $# -eq 0 ] && print_error_and_exit "[$FUNCNAME] please precise what you want to set"
    local function=""
    while [ $# -ge 1 ]; do
        case $1 in
            -h | --help)    print_help;        exit 0;;
            -V | --version) print_version;     exit 0;;
            -f | --force)   FORCE="--force";;
            --debug)        DEBUG="--debug";;
            --all)          NODES="${ALL_CLUSTER_NODES}";;
            -v | --verbose) VERBOSE="-v";;
            -r | --reboot | reboot )      MODE_REBOOT="--reboot";;
            -s | --softmod)           MODE_SOFTREBOOT="--soft";;
            -i | --install | install)     function="configure_PXE_boot";;
            -l | --localboot | localboot) function="configure_localdisk_boot";;
            --bcs) LIVE_NETDEV="eth0";;
            --live-netdev)
                shift;
                LIVE_NETDEV="$1";;
            *)  [ -z "$function" ] && print_error_and_exit "[$FUNCNAME] unknown get option";
                configure_nodes_variable $@
        esac
        shift
    done
    #[ -n "${MODE_REBOOT}" ] && check_nodes_availability  # ensure all the nodes are accessible
    eval $function
    exit 0;
}

#####
# handle the get command to obtain various configuration information
###
get_config() {
    [ $# -eq 0 ] && print_error_and_exit "[$FUNCNAME] please precise what you want to set"
    local function=""
    while [ $# -ge 1 ]; do
        case $1 in
            -h | --help)    print_help;        exit 0;;
            -V | --version) print_version;     exit 0;;
            --debug)        DEBUG="--debug";;
            --all)          NODES="${ALL_CLUSTER_NODES}";;
            -v | --verbose) VERBOSE="-v";;
            -b | --boot-mode | boot-mode)  function="get_boot_mode";;
            *)  [ -z "$function" ] && print_error_and_exit "[$FUNCNAME] unknown get option";
                configure_nodes_variable $@
        esac
        shift
    done
    #check_nodes_availability  # ensure all the nodes are accessible
    eval $function
    exit 0;
}

################################################################################
################################################################################
#[ $UID -gt 0 ] && print_error_and_exit "You must be root to execute this script (current uid: $UID)"

# Check for required argument
[ $# -eq 0 ] && print_error_and_exit

# Check for options
while [ $# -ge 1 ]; do
    case $1 in
        # General options
        -f | --force)   FORCE="--force";;
        --debug)        DEBUG="--debug";;
        --all)          NODES="${ALL_CLUSTER_NODES}";;
        -h | --help)    print_help;        exit 0;;
        -V | --version) print_version;     exit 0;;
        -v | --verbose) VERBOSE="-v";;

        # Specific options
        cleanssh)  cleanssh; exit 0;;
        #   command)    shift; configure_nodes_variable $1;
        get)        shift; get_config $@;       exit 0;; # get various configuration information
        set)        shift; set_config $@;       exit 0;; # configure the way the nodes boot, are formatted etc.
        setup)      fai_setup;                  exit 0;; # FAI setup
        status)     MODE_STATUS="--install";;            # get state info on the nodes
        ssh)        # connect by SSH on the specified node
            shift
            configure_nodes_variable $@
            sshconnect_to
            exit 0;;
        -m | --monitor | monitor) shift; monitor $@;          exit 0;; # monitor logs during FAI operations
        -i | --install | install) MODE_INSTALL="--install";;
        -r | --reboot  | reboot ) MODE_REBOOT="--reboot";;
        -s | --softmod)           MODE_SOFTREBOOT="--soft";;
        -c | --check-ssh)         MODE_CHECKSSH="--check-ssh";;
        *) configure_nodes_variable "$@"; break;;
    esac
    shift
done
configure_nodes_variable
[ -n "${MODE_STATUS}"   ] && status                         && exit 0
[ -z "${MODE_REBOOT}"   ] && check_nodes_availability                    # check SSH access on nodes
[ -n "${MODE_CHECKSSH}" ] && info "mode check SSH: exiting" && exit 0
[ -n "${MODE_INSTALL}"  ] && install                        && exit 0
[ -n "${MODE_REBOOT}"   ] && reboot                         && exit 0

exit 0
